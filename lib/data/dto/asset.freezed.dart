// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'asset.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AssetDTO _$AssetDTOFromJson(Map<String, dynamic> json) {
  return _AssetDTO.fromJson(json);
}

/// @nodoc
mixin _$AssetDTO {
  String get assetId => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get typeIsCrypto => throw _privateConstructorUsedError;
  String get dataStart => throw _privateConstructorUsedError;
  String get dataEnd => throw _privateConstructorUsedError;
  String get dataQuoteStart => throw _privateConstructorUsedError;
  String get dataQuoteEnd => throw _privateConstructorUsedError;
  String get dataOrderbookStart => throw _privateConstructorUsedError;
  String get dataOrderbookEnd => throw _privateConstructorUsedError;
  String get dataTradeStart => throw _privateConstructorUsedError;
  String get dataTradeEnd => throw _privateConstructorUsedError;
  int get dataSymbolsCount => throw _privateConstructorUsedError;
  int get volume1hrsUsd => throw _privateConstructorUsedError;
  int get volume1dayUsd => throw _privateConstructorUsedError;
  int get volume1mthUsd => throw _privateConstructorUsedError;
  int get priceUsd => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetDTOCopyWith<AssetDTO> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetDTOCopyWith<$Res> {
  factory $AssetDTOCopyWith(AssetDTO value, $Res Function(AssetDTO) then) =
      _$AssetDTOCopyWithImpl<$Res>;
  $Res call(
      {String assetId,
      String name,
      bool typeIsCrypto,
      String dataStart,
      String dataEnd,
      String dataQuoteStart,
      String dataQuoteEnd,
      String dataOrderbookStart,
      String dataOrderbookEnd,
      String dataTradeStart,
      String dataTradeEnd,
      int dataSymbolsCount,
      int volume1hrsUsd,
      int volume1dayUsd,
      int volume1mthUsd,
      int priceUsd});
}

/// @nodoc
class _$AssetDTOCopyWithImpl<$Res> implements $AssetDTOCopyWith<$Res> {
  _$AssetDTOCopyWithImpl(this._value, this._then);

  final AssetDTO _value;
  // ignore: unused_field
  final $Res Function(AssetDTO) _then;

  @override
  $Res call({
    Object? assetId = freezed,
    Object? name = freezed,
    Object? typeIsCrypto = freezed,
    Object? dataStart = freezed,
    Object? dataEnd = freezed,
    Object? dataQuoteStart = freezed,
    Object? dataQuoteEnd = freezed,
    Object? dataOrderbookStart = freezed,
    Object? dataOrderbookEnd = freezed,
    Object? dataTradeStart = freezed,
    Object? dataTradeEnd = freezed,
    Object? dataSymbolsCount = freezed,
    Object? volume1hrsUsd = freezed,
    Object? volume1dayUsd = freezed,
    Object? volume1mthUsd = freezed,
    Object? priceUsd = freezed,
  }) {
    return _then(_value.copyWith(
      assetId: assetId == freezed
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      typeIsCrypto: typeIsCrypto == freezed
          ? _value.typeIsCrypto
          : typeIsCrypto // ignore: cast_nullable_to_non_nullable
              as bool,
      dataStart: dataStart == freezed
          ? _value.dataStart
          : dataStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataEnd: dataEnd == freezed
          ? _value.dataEnd
          : dataEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataQuoteStart: dataQuoteStart == freezed
          ? _value.dataQuoteStart
          : dataQuoteStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataQuoteEnd: dataQuoteEnd == freezed
          ? _value.dataQuoteEnd
          : dataQuoteEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataOrderbookStart: dataOrderbookStart == freezed
          ? _value.dataOrderbookStart
          : dataOrderbookStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataOrderbookEnd: dataOrderbookEnd == freezed
          ? _value.dataOrderbookEnd
          : dataOrderbookEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataTradeStart: dataTradeStart == freezed
          ? _value.dataTradeStart
          : dataTradeStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataTradeEnd: dataTradeEnd == freezed
          ? _value.dataTradeEnd
          : dataTradeEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataSymbolsCount: dataSymbolsCount == freezed
          ? _value.dataSymbolsCount
          : dataSymbolsCount // ignore: cast_nullable_to_non_nullable
              as int,
      volume1hrsUsd: volume1hrsUsd == freezed
          ? _value.volume1hrsUsd
          : volume1hrsUsd // ignore: cast_nullable_to_non_nullable
              as int,
      volume1dayUsd: volume1dayUsd == freezed
          ? _value.volume1dayUsd
          : volume1dayUsd // ignore: cast_nullable_to_non_nullable
              as int,
      volume1mthUsd: volume1mthUsd == freezed
          ? _value.volume1mthUsd
          : volume1mthUsd // ignore: cast_nullable_to_non_nullable
              as int,
      priceUsd: priceUsd == freezed
          ? _value.priceUsd
          : priceUsd // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$$_AssetDTOCopyWith<$Res> implements $AssetDTOCopyWith<$Res> {
  factory _$$_AssetDTOCopyWith(
          _$_AssetDTO value, $Res Function(_$_AssetDTO) then) =
      __$$_AssetDTOCopyWithImpl<$Res>;
  @override
  $Res call(
      {String assetId,
      String name,
      bool typeIsCrypto,
      String dataStart,
      String dataEnd,
      String dataQuoteStart,
      String dataQuoteEnd,
      String dataOrderbookStart,
      String dataOrderbookEnd,
      String dataTradeStart,
      String dataTradeEnd,
      int dataSymbolsCount,
      int volume1hrsUsd,
      int volume1dayUsd,
      int volume1mthUsd,
      int priceUsd});
}

/// @nodoc
class __$$_AssetDTOCopyWithImpl<$Res> extends _$AssetDTOCopyWithImpl<$Res>
    implements _$$_AssetDTOCopyWith<$Res> {
  __$$_AssetDTOCopyWithImpl(
      _$_AssetDTO _value, $Res Function(_$_AssetDTO) _then)
      : super(_value, (v) => _then(v as _$_AssetDTO));

  @override
  _$_AssetDTO get _value => super._value as _$_AssetDTO;

  @override
  $Res call({
    Object? assetId = freezed,
    Object? name = freezed,
    Object? typeIsCrypto = freezed,
    Object? dataStart = freezed,
    Object? dataEnd = freezed,
    Object? dataQuoteStart = freezed,
    Object? dataQuoteEnd = freezed,
    Object? dataOrderbookStart = freezed,
    Object? dataOrderbookEnd = freezed,
    Object? dataTradeStart = freezed,
    Object? dataTradeEnd = freezed,
    Object? dataSymbolsCount = freezed,
    Object? volume1hrsUsd = freezed,
    Object? volume1dayUsd = freezed,
    Object? volume1mthUsd = freezed,
    Object? priceUsd = freezed,
  }) {
    return _then(_$_AssetDTO(
      assetId: assetId == freezed
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      typeIsCrypto: typeIsCrypto == freezed
          ? _value.typeIsCrypto
          : typeIsCrypto // ignore: cast_nullable_to_non_nullable
              as bool,
      dataStart: dataStart == freezed
          ? _value.dataStart
          : dataStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataEnd: dataEnd == freezed
          ? _value.dataEnd
          : dataEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataQuoteStart: dataQuoteStart == freezed
          ? _value.dataQuoteStart
          : dataQuoteStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataQuoteEnd: dataQuoteEnd == freezed
          ? _value.dataQuoteEnd
          : dataQuoteEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataOrderbookStart: dataOrderbookStart == freezed
          ? _value.dataOrderbookStart
          : dataOrderbookStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataOrderbookEnd: dataOrderbookEnd == freezed
          ? _value.dataOrderbookEnd
          : dataOrderbookEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataTradeStart: dataTradeStart == freezed
          ? _value.dataTradeStart
          : dataTradeStart // ignore: cast_nullable_to_non_nullable
              as String,
      dataTradeEnd: dataTradeEnd == freezed
          ? _value.dataTradeEnd
          : dataTradeEnd // ignore: cast_nullable_to_non_nullable
              as String,
      dataSymbolsCount: dataSymbolsCount == freezed
          ? _value.dataSymbolsCount
          : dataSymbolsCount // ignore: cast_nullable_to_non_nullable
              as int,
      volume1hrsUsd: volume1hrsUsd == freezed
          ? _value.volume1hrsUsd
          : volume1hrsUsd // ignore: cast_nullable_to_non_nullable
              as int,
      volume1dayUsd: volume1dayUsd == freezed
          ? _value.volume1dayUsd
          : volume1dayUsd // ignore: cast_nullable_to_non_nullable
              as int,
      volume1mthUsd: volume1mthUsd == freezed
          ? _value.volume1mthUsd
          : volume1mthUsd // ignore: cast_nullable_to_non_nullable
              as int,
      priceUsd: priceUsd == freezed
          ? _value.priceUsd
          : priceUsd // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AssetDTO implements _AssetDTO {
  const _$_AssetDTO(
      {required this.assetId,
      required this.name,
      required this.typeIsCrypto,
      required this.dataStart,
      required this.dataEnd,
      required this.dataQuoteStart,
      required this.dataQuoteEnd,
      required this.dataOrderbookStart,
      required this.dataOrderbookEnd,
      required this.dataTradeStart,
      required this.dataTradeEnd,
      required this.dataSymbolsCount,
      required this.volume1hrsUsd,
      required this.volume1dayUsd,
      required this.volume1mthUsd,
      required this.priceUsd});

  factory _$_AssetDTO.fromJson(Map<String, dynamic> json) =>
      _$$_AssetDTOFromJson(json);

  @override
  final String assetId;
  @override
  final String name;
  @override
  final bool typeIsCrypto;
  @override
  final String dataStart;
  @override
  final String dataEnd;
  @override
  final String dataQuoteStart;
  @override
  final String dataQuoteEnd;
  @override
  final String dataOrderbookStart;
  @override
  final String dataOrderbookEnd;
  @override
  final String dataTradeStart;
  @override
  final String dataTradeEnd;
  @override
  final int dataSymbolsCount;
  @override
  final int volume1hrsUsd;
  @override
  final int volume1dayUsd;
  @override
  final int volume1mthUsd;
  @override
  final int priceUsd;

  @override
  String toString() {
    return 'AssetDTO(assetId: $assetId, name: $name, typeIsCrypto: $typeIsCrypto, dataStart: $dataStart, dataEnd: $dataEnd, dataQuoteStart: $dataQuoteStart, dataQuoteEnd: $dataQuoteEnd, dataOrderbookStart: $dataOrderbookStart, dataOrderbookEnd: $dataOrderbookEnd, dataTradeStart: $dataTradeStart, dataTradeEnd: $dataTradeEnd, dataSymbolsCount: $dataSymbolsCount, volume1hrsUsd: $volume1hrsUsd, volume1dayUsd: $volume1dayUsd, volume1mthUsd: $volume1mthUsd, priceUsd: $priceUsd)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AssetDTO &&
            const DeepCollectionEquality().equals(other.assetId, assetId) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.typeIsCrypto, typeIsCrypto) &&
            const DeepCollectionEquality().equals(other.dataStart, dataStart) &&
            const DeepCollectionEquality().equals(other.dataEnd, dataEnd) &&
            const DeepCollectionEquality()
                .equals(other.dataQuoteStart, dataQuoteStart) &&
            const DeepCollectionEquality()
                .equals(other.dataQuoteEnd, dataQuoteEnd) &&
            const DeepCollectionEquality()
                .equals(other.dataOrderbookStart, dataOrderbookStart) &&
            const DeepCollectionEquality()
                .equals(other.dataOrderbookEnd, dataOrderbookEnd) &&
            const DeepCollectionEquality()
                .equals(other.dataTradeStart, dataTradeStart) &&
            const DeepCollectionEquality()
                .equals(other.dataTradeEnd, dataTradeEnd) &&
            const DeepCollectionEquality()
                .equals(other.dataSymbolsCount, dataSymbolsCount) &&
            const DeepCollectionEquality()
                .equals(other.volume1hrsUsd, volume1hrsUsd) &&
            const DeepCollectionEquality()
                .equals(other.volume1dayUsd, volume1dayUsd) &&
            const DeepCollectionEquality()
                .equals(other.volume1mthUsd, volume1mthUsd) &&
            const DeepCollectionEquality().equals(other.priceUsd, priceUsd));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(assetId),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(typeIsCrypto),
      const DeepCollectionEquality().hash(dataStart),
      const DeepCollectionEquality().hash(dataEnd),
      const DeepCollectionEquality().hash(dataQuoteStart),
      const DeepCollectionEquality().hash(dataQuoteEnd),
      const DeepCollectionEquality().hash(dataOrderbookStart),
      const DeepCollectionEquality().hash(dataOrderbookEnd),
      const DeepCollectionEquality().hash(dataTradeStart),
      const DeepCollectionEquality().hash(dataTradeEnd),
      const DeepCollectionEquality().hash(dataSymbolsCount),
      const DeepCollectionEquality().hash(volume1hrsUsd),
      const DeepCollectionEquality().hash(volume1dayUsd),
      const DeepCollectionEquality().hash(volume1mthUsd),
      const DeepCollectionEquality().hash(priceUsd));

  @JsonKey(ignore: true)
  @override
  _$$_AssetDTOCopyWith<_$_AssetDTO> get copyWith =>
      __$$_AssetDTOCopyWithImpl<_$_AssetDTO>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetDTOToJson(this);
  }
}

abstract class _AssetDTO implements AssetDTO {
  const factory _AssetDTO(
      {required final String assetId,
      required final String name,
      required final bool typeIsCrypto,
      required final String dataStart,
      required final String dataEnd,
      required final String dataQuoteStart,
      required final String dataQuoteEnd,
      required final String dataOrderbookStart,
      required final String dataOrderbookEnd,
      required final String dataTradeStart,
      required final String dataTradeEnd,
      required final int dataSymbolsCount,
      required final int volume1hrsUsd,
      required final int volume1dayUsd,
      required final int volume1mthUsd,
      required final int priceUsd}) = _$_AssetDTO;

  factory _AssetDTO.fromJson(Map<String, dynamic> json) = _$_AssetDTO.fromJson;

  @override
  String get assetId => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get typeIsCrypto => throw _privateConstructorUsedError;
  @override
  String get dataStart => throw _privateConstructorUsedError;
  @override
  String get dataEnd => throw _privateConstructorUsedError;
  @override
  String get dataQuoteStart => throw _privateConstructorUsedError;
  @override
  String get dataQuoteEnd => throw _privateConstructorUsedError;
  @override
  String get dataOrderbookStart => throw _privateConstructorUsedError;
  @override
  String get dataOrderbookEnd => throw _privateConstructorUsedError;
  @override
  String get dataTradeStart => throw _privateConstructorUsedError;
  @override
  String get dataTradeEnd => throw _privateConstructorUsedError;
  @override
  int get dataSymbolsCount => throw _privateConstructorUsedError;
  @override
  int get volume1hrsUsd => throw _privateConstructorUsedError;
  @override
  int get volume1dayUsd => throw _privateConstructorUsedError;
  @override
  int get volume1mthUsd => throw _privateConstructorUsedError;
  @override
  int get priceUsd => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AssetDTOCopyWith<_$_AssetDTO> get copyWith =>
      throw _privateConstructorUsedError;
}
